/// SP3 Cross-Language E2E Tests
///
/// Consumes proof artifacts generated by the Rust prover (stwo-ml) and verifies
/// them in Cairo. This is the MOST IMPORTANT test category — it proves that
/// the Cairo verifier produces identical Fiat-Shamir transcripts as the Rust
/// prover, which is the foundation of soundness.
///
/// Artifact: stwo-ml/tests/artifacts/sp3_matmul_only_proof.json
///   Model: 1x4 input → MatMul(4x2) → 1x2 output
///   Input: [1, 2, 3, 4], Output: [50, 60]
///   Calldata: v19 compressed format (c1 omitted), 1 weight commitment, 2 sumcheck rounds
///
/// v19 transcript changes:
///   - mix_secure_field uses packed felt252 (1 hades) instead of 4 mix_u64
///   - Round polynomials compressed: c1 omitted, reconstructed by verifier
///   - channel_mix_poly_coeffs uses batched packing

use elo_cairo_verifier::field::{
    QM31, CM31, qm31_new, qm31_eq, fold_mle_eval,
};
use elo_cairo_verifier::channel::{
    PoseidonChannel, channel_default, channel_mix_u64,
    channel_mix_secure_field, channel_draw_qm31,
};
use elo_cairo_verifier::types::{GKRClaim, MleOpeningProof};
use elo_cairo_verifier::model_verifier::verify_gkr_model;
use elo_cairo_verifier::mle::verify_mle_opening;

// ============================================================================
// Helpers
// ============================================================================

/// Real-only QM31 from a u64.
fn mk(a: u64) -> QM31 {
    QM31 { a: CM31 { a, b: 0 }, b: CM31 { a: 0, b: 0 } }
}

/// Seed the channel identically to the Rust GKR prover/verifier.
///
/// Rust seeding (gkr/verifier.rs:56-59):
///   channel.mix_u64(d);              // number of layers
///   channel.mix_u64(input_rows);     // input shape row
///   channel.mix_u64(input_cols);     // input shape col
fn seed_channel_rust(ref ch: PoseidonChannel, d: u64, input_rows: u64, input_cols: u64) {
    channel_mix_u64(ref ch, d);
    channel_mix_u64(ref ch, input_rows);
    channel_mix_u64(ref ch, input_cols);
}

/// Construct the initial output claim by:
///   1. Drawing log_out_vars random QM31 challenges
///   2. Evaluating the output MLE at those challenges
///   3. Mixing the output value into the channel
///
/// For output [50, 60] (1x2 matrix, log_vars=1):
///   r_out = [draw_qm31()]
///   output_value = fold_mle_eval(r0, mk(50), mk(60))
///   mix_secure_field(output_value)
fn construct_output_claim(
    ref ch: PoseidonChannel, output_v0: u64, output_v1: u64,
) -> GKRClaim {
    // Draw 1 QM31 challenge (log_out_rows=0, log_out_cols=1, total=1)
    let r0 = channel_draw_qm31(ref ch);

    // Evaluate output MLE: f(r0) = v0*(1-r0) + v1*r0
    let output_value = fold_mle_eval(r0, mk(output_v0), mk(output_v1));

    // Mix output value into channel
    channel_mix_secure_field(ref ch, output_value);

    GKRClaim {
        point: array![r0],
        value: output_value,
    }
}

/// Build the proof_data from the SP3 matmul-only artifact (v19 compressed format).
///
/// v19 compressed: c1 is omitted from each round (reconstructed by verifier).
///   [0] tag=0 (MatMul)
///   [1] num_rounds=2
///   [2..9]   round[0]: c0(4), c2(4)
///   [10..17] round[1]: c0(4), c2(4)
///   [18..21] final_a_eval (QM31)
///   [22..25] final_b_eval (QM31)
///   [26]     num_deferred=0
fn build_sp3_matmul_only_proof_data() -> Array<felt252> {
    array![
        // tag = MatMul (0)
        0x0,
        // num_rounds = 2
        0x2,
        // round[0].c0 (QM31)
        0x4c3999da, 0x34cddf9a, 0x447004b2, 0x4b11507f,
        // round[0].c2 (QM31) — c1 omitted
        0x10, 0x0, 0x0, 0x0,
        // round[1].c0 (QM31)
        0x59c30da5, 0x57a1304f, 0x61fa59de, 0x5d27936d,
        // round[1].c2 (QM31) — c1 omitted
        0x2, 0x0, 0x0, 0x0,
        // final_a_eval (QM31)
        0x300af73c, 0x7b4d242b, 0x4992e6b7, 0x2b489ae1,
        // final_b_eval (QM31)
        0x242921be, 0x5d8992e0, 0x54a079aa, 0x1a41a5ed,
        // num_deferred = 0 (no DAG Add layers)
        0x0,
    ]
}

// ============================================================================
// Test 1: SP3 Matmul-Only — Channel Digest Matches Rust
// ============================================================================

/// Full cross-language verification:
///   1. Seed channel identically to Rust prover
///   2. Construct initial output claim from output=[50,60]
///   3. Run verify_gkr_model with proof_data from artifact
///   4. Assert final channel digest == Rust's final_channel_digest
///
/// This test catches ANY Fiat-Shamir transcript divergence between
/// Cairo and Rust — the most critical soundness property.
#[test]
fn test_sp3_matmul_only_channel_digest() {
    let mut ch = channel_default();

    // 1. Seed channel (Rust protocol: d, input_rows, input_cols)
    seed_channel_rust(ref ch, 1, 1, 4);

    // 2. Construct initial output claim
    //    Output: [50, 60] → 1×2 matrix → MLE over 1 variable
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    // 3. Run GKR model verification
    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2]; // m=1, k=4, n=2

    let (_final_claim, _) = verify_gkr_model(
        proof_data.span(),
        1,                          // num_layers
        matmul_dims.span(),
        array![].span(),            // no dequantize layers
        initial_claim,
        ref ch,
    );

    // 4. Assert channel digest matches Rust artifact (v19 transcript)
    let expected_digest: felt252 =
        0x0422e91b535975516578d8ab499ff4ec4750ee08dffaffce8a22628df3ce0f05;

    assert!(ch.digest == expected_digest, "SP3_DIGEST_MISMATCH");
}

// ============================================================================
// Test 2: SP3 Matmul-Only — Final Claim Value Matches Rust
// ============================================================================

/// Verify that the final claim (input claim) from verify_gkr_model
/// matches the expected input_claim.value from the Rust artifact.
///
/// For a single MatMul layer, the final claim value should equal
/// final_a_eval from the sumcheck proof.
#[test]
fn test_sp3_matmul_only_final_claim_value() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (final_claim, _) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );

    // From artifact: input_claim.value = final_a_eval (v19)
    let expected_value = qm31_new(0x300af73c, 0x7b4d242b, 0x4992e6b7, 0x2b489ae1);
    assert!(qm31_eq(final_claim.value, expected_value), "SP3_CLAIM_VALUE_MISMATCH");

    // Final claim point should have 2 elements (log_m=0 + log_k=2 sumcheck challenges)
    assert!(final_claim.point.len() == 2, "SP3_CLAIM_POINT_LEN");
}

// ============================================================================
// Test 3: SP3 Matmul-Only — Final Claim Point Matches Rust
// ============================================================================

/// Verify the final claim point coordinates match the artifact's input_claim.point.
/// Point = [s0, s1] — the 2 sumcheck challenges from the MatMul reduction.
#[test]
fn test_sp3_matmul_only_final_claim_point() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (final_claim, _) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );

    // From artifact: input_claim.point (v19)
    let expected_p0 = qm31_new(0x77413964, 0x7262e408, 0x3155525d, 0x50889bd9);
    let expected_p1 = qm31_new(0x41888471, 0x16875c1a, 0x66e841fc, 0xa37632e);

    let point_span = final_claim.point.span();
    assert!(qm31_eq(*point_span.at(0), expected_p0), "SP3_POINT_0_MISMATCH");
    assert!(qm31_eq(*point_span.at(1), expected_p1), "SP3_POINT_1_MISMATCH");
}

// ============================================================================
// Test 4: SP3 Tampered Round Poly — Rejected
// ============================================================================

/// Tamper the first round polynomial coefficient (c0) in the MatMul proof.
/// With v19 compressed polys, c1 is reconstructed to satisfy the round sum
/// by construction, so the tampering propagates to MATMUL_FINAL_MISMATCH
/// (final_a * final_b != evaluated poly at challenge).
#[test]
#[should_panic(expected: "MATMUL_FINAL_MISMATCH")]
fn test_sp3_matmul_only_tampered_rejects() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    // Build proof data with tampered round[0].c0 (first QM31 component +1)
    let proof_data: Array<felt252> = array![
        0x0,          // tag
        0x2,          // num_rounds
        // round[0].c0 — TAMPERED: 0x4c3999da → 0x4c3999db (+1)
        0x4c3999db, 0x34cddf9a, 0x447004b2, 0x4b11507f,
        // round[0].c2
        0x10, 0x0, 0x0, 0x0,
        // round[1].c0
        0x59c30da5, 0x57a1304f, 0x61fa59de, 0x5d27936d,
        // round[1].c2
        0x2, 0x0, 0x0, 0x0,
        // final_a_eval
        0x300af73c, 0x7b4d242b, 0x4992e6b7, 0x2b489ae1,
        // final_b_eval
        0x242921be, 0x5d8992e0, 0x54a079aa, 0x1a41a5ed,
    ];

    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, _) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );
}

// ============================================================================
// Test 5: SP3 Tampered Final Eval — Rejected
// ============================================================================

/// Tamper the final_a_eval. The verifier should detect this via
/// MATMUL_FINAL_MISMATCH (final_a * final_b != last round sum).
#[test]
#[should_panic(expected: "MATMUL_FINAL_MISMATCH")]
fn test_sp3_matmul_only_tampered_final_rejects() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    // Build proof data with tampered final_a_eval (first component +1)
    let proof_data: Array<felt252> = array![
        0x0,
        0x2,
        // round[0].c0
        0x4c3999da, 0x34cddf9a, 0x447004b2, 0x4b11507f,
        // round[0].c2
        0x10, 0x0, 0x0, 0x0,
        // round[1].c0
        0x59c30da5, 0x57a1304f, 0x61fa59de, 0x5d27936d,
        // round[1].c2
        0x2, 0x0, 0x0, 0x0,
        // final_a_eval — TAMPERED: 0x300af73c → 0x300af73d (+1)
        0x300af73d, 0x7b4d242b, 0x4992e6b7, 0x2b489ae1,
        // final_b_eval
        0x242921be, 0x5d8992e0, 0x54a079aa, 0x1a41a5ed,
    ];

    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, _) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );
}

// ============================================================================
// Test 6: SP3 Wrong Output — Initial Claim Mismatch
// ============================================================================

/// Provide wrong output values (51, 60 instead of 50, 60).
/// The initial claim value will differ → with v19 compressed polys, c1 is
/// reconstructed from the wrong claim, producing wrong Fiat-Shamir challenge,
/// which propagates to MATMUL_FINAL_MISMATCH.
#[test]
#[should_panic(expected: "MATMUL_FINAL_MISMATCH")]
fn test_sp3_matmul_only_wrong_output_rejects() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);

    // Wrong output: [51, 60] instead of [50, 60]
    let initial_claim = construct_output_claim(ref ch, 51, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, _) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );
}

// ============================================================================
// Weight MLE Opening Proof Data (from sp3_matmul_only_proof.json, v19)
// ============================================================================

/// Build the MleOpeningProof calldata from the SP3 artifact (v19).
///
/// 184 felts encoding a single MleOpeningProof for the 4x2 weight matrix.
/// MLE has 8 elements (4*2), log2(8)=3 folding rounds, 4 spot-check queries.
/// Merkle tree: 2 intermediate roots, 4 queries x 3 rounds each.
///
/// Note: intermediate_roots[1] changed in v19 because the weight eval points
/// changed (different Fiat-Shamir challenges from the new transcript).
fn build_sp3_weight_opening_proof_data() -> Array<felt252> {
    array![
        // intermediate_roots: Array<felt252> (len=2)
        0x2,
        0x32af8fd28517d67b4a36b4a05b422da2d55a15a9c1d6ffd2c99bed93b1e3659,
        0x6fe0b662f3b2a5ca034bbebe1d6750d4bc1a4feeef133ee5db36116585e04a9,
        // queries: Array<MleQueryProof> (len=4)
        0x4,
        // ---- Query 0: initial_pair_index=0, rounds=3 ----
        0x0, 0x3,
        0x1, 0x0, 0x0, 0x0,
        0x2, 0x0, 0x0, 0x0,
        0x3,
        0x10000000600000000000000000000000,
        0x237489190b283d778a874e504a4e6f70b5971003c8fbd81654e589ffb30450,
        0x523409a865968ce30bd0ff99140c9dc235ec925370279c43d59beb5bfe4c1ac,
        0x3,
        0x10000000800000000000000000000000,
        0x495ab9242f2ec905679ed8d6af6414b4dc897336d31719b68e573911043c180,
        0x12a72ae943d9780522015b25a33677c130cf2e3ca7cab6111f387c0572cea41,
        // Q0 R1
        0x44133347, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x4413334b, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x2,
        0x1882666939bbd2a220bd561dc3b0702a,
        0x4458b2d010efa202ef05ef9980c80ca06d4d8bd4718b512a20cecc76818631,
        0x2,
        0x18826669b9bbd2a220bd561dc3b0702a,
        0xf7e1013873b4fe7e32273e9ea1aa97c075a6111259f180555224f386c5510f,
        // Q0 R2
        0x211818db, 0x307adaac, 0x6cff5b1, 0x5d2df91,
        0x211818dd, 0x307adaac, 0x6cff5b1, 0x5d2df91,
        0x1,
        0x1423031bac1eb6ab0367fad885d2df91,
        0x1,
        0x1423031b6c1eb6ab0367fad885d2df91,
        // ---- Query 1: initial_pair_index=3, rounds=3 ----
        0x3, 0x3,
        0x7, 0x0, 0x0, 0x0,
        0x8, 0x0, 0x0, 0x0,
        0x3,
        0x10000000a00000000000000000000000,
        0x1b537b28eb8c5c619cecea97d60b41e915ab177027b4ef363162ca5742e2184,
        0x523409a865968ce30bd0ff99140c9dc235ec925370279c43d59beb5bfe4c1ac,
        0x3,
        0x10000000c00000000000000000000000,
        0x7629454ecc4eaca72b489df1ec392edf4bb1df3dca0b8c3bbf5ab1d1a1cbd9f,
        0x12a72ae943d9780522015b25a33677c130cf2e3ca7cab6111f387c0572cea41,
        // Q1 R1
        0x44133349, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x4413334d, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x2,
        0x18826668f9bbd2a220bd561dc3b0702a,
        0x4458b2d010efa202ef05ef9980c80ca06d4d8bd4718b512a20cecc76818631,
        0x2,
        0x1882666979bbd2a220bd561dc3b0702a,
        0xf7e1013873b4fe7e32273e9ea1aa97c075a6111259f180555224f386c5510f,
        // Q1 R2
        0x211818db, 0x307adaac, 0x6cff5b1, 0x5d2df91,
        0x211818dd, 0x307adaac, 0x6cff5b1, 0x5d2df91,
        0x1,
        0x1423031bac1eb6ab0367fad885d2df91,
        0x1,
        0x1423031b6c1eb6ab0367fad885d2df91,
        // ---- Query 2: initial_pair_index=1, rounds=3 ----
        0x1, 0x3,
        0x3, 0x0, 0x0, 0x0,
        0x4, 0x0, 0x0, 0x0,
        0x3,
        0x10000000200000000000000000000000,
        0x237489190b283d778a874e504a4e6f70b5971003c8fbd81654e589ffb30450,
        0x523409a865968ce30bd0ff99140c9dc235ec925370279c43d59beb5bfe4c1ac,
        0x3,
        0x10000000400000000000000000000000,
        0x495ab9242f2ec905679ed8d6af6414b4dc897336d31719b68e573911043c180,
        0x12a72ae943d9780522015b25a33677c130cf2e3ca7cab6111f387c0572cea41,
        // Q2 R1
        0x44133349, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x4413334d, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x2,
        0x18826668f9bbd2a220bd561dc3b0702a,
        0x4458b2d010efa202ef05ef9980c80ca06d4d8bd4718b512a20cecc76818631,
        0x2,
        0x1882666979bbd2a220bd561dc3b0702a,
        0xf7e1013873b4fe7e32273e9ea1aa97c075a6111259f180555224f386c5510f,
        // Q2 R2
        0x211818db, 0x307adaac, 0x6cff5b1, 0x5d2df91,
        0x211818dd, 0x307adaac, 0x6cff5b1, 0x5d2df91,
        0x1,
        0x1423031bac1eb6ab0367fad885d2df91,
        0x1,
        0x1423031b6c1eb6ab0367fad885d2df91,
        // ---- Query 3: initial_pair_index=2, rounds=3 ----
        0x2, 0x3,
        0x5, 0x0, 0x0, 0x0,
        0x6, 0x0, 0x0, 0x0,
        0x3,
        0x10000000e00000000000000000000000,
        0x1b537b28eb8c5c619cecea97d60b41e915ab177027b4ef363162ca5742e2184,
        0x523409a865968ce30bd0ff99140c9dc235ec925370279c43d59beb5bfe4c1ac,
        0x3,
        0x10000001000000000000000000000000,
        0x7629454ecc4eaca72b489df1ec392edf4bb1df3dca0b8c3bbf5ab1d1a1cbd9f,
        0x12a72ae943d9780522015b25a33677c130cf2e3ca7cab6111f387c0572cea41,
        // Q3 R1
        0x44133347, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x4413334b, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x2,
        0x1882666939bbd2a220bd561dc3b0702a,
        0x4458b2d010efa202ef05ef9980c80ca06d4d8bd4718b512a20cecc76818631,
        0x2,
        0x18826669b9bbd2a220bd561dc3b0702a,
        0xf7e1013873b4fe7e32273e9ea1aa97c075a6111259f180555224f386c5510f,
        // Q3 R2
        0x211818db, 0x307adaac, 0x6cff5b1, 0x5d2df91,
        0x211818dd, 0x307adaac, 0x6cff5b1, 0x5d2df91,
        0x1,
        0x1423031bac1eb6ab0367fad885d2df91,
        0x1,
        0x1423031b6c1eb6ab0367fad885d2df91,
        // final_value: QM31(0x242921be, 0x5d8992e0, 0x54a079aa, 0x1a41a5ed)
        0x242921be, 0x5d8992e0, 0x54a079aa, 0x1a41a5ed,
    ]
}

// ============================================================================
// Test 7: SP3 Matmul-Only -- Weight Claims Match Artifact
// ============================================================================

/// Verify that the weight claims collected during the GKR walk match the
/// hardcoded values from the Rust artifact (v19).
#[test]
fn test_sp3_weight_claims_match_artifact() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, weight_claims) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );

    // Should have exactly 1 weight claim (1 matmul layer)
    assert!(weight_claims.len() == 1, "SP3_WEIGHT_CLAIM_COUNT");

    let wc_span = weight_claims.span();
    let claim = wc_span.at(0);

    // eval_point should have 3 QM31s: [r_j(1), s0(1), s1(1)]
    assert!(claim.eval_point.len() == 3, "SP3_EVAL_POINT_LEN");

    // From artifact (v19): weight_claims[0].eval_point
    let ep0 = qm31_new(0x44133346, 0x66ef4a88, 0x417aac3b, 0x43b0702a);
    let ep1 = qm31_new(0x77413964, 0x7262e408, 0x3155525d, 0x50889bd9);
    let ep2 = qm31_new(0x41888471, 0x16875c1a, 0x66e841fc, 0xa37632e);

    assert!(qm31_eq(*claim.eval_point.at(0), ep0), "SP3_EVAL_POINT_0");
    assert!(qm31_eq(*claim.eval_point.at(1), ep1), "SP3_EVAL_POINT_1");
    assert!(qm31_eq(*claim.eval_point.at(2), ep2), "SP3_EVAL_POINT_2");

    // From artifact (v19): weight_claims[0].expected_value = final_b_eval
    let expected_val = qm31_new(0x242921be, 0x5d8992e0, 0x54a079aa, 0x1a41a5ed);
    assert!(qm31_eq(*claim.expected_value, expected_val), "SP3_WEIGHT_VALUE");
}

// ============================================================================
// Test 8: SP3 Matmul-Only -- Weight MLE Opening Verification Passes
// ============================================================================

/// Full cross-language weight opening verification:
///   1. Run GKR model walk to get weight claims + channel state
///   2. Deserialize MleOpeningProof from artifact data via Serde
///   3. Call verify_mle_opening with the weight commitment from artifact
///   4. Assert verification passes
///   5. Assert final channel digest matches Rust's digest_after_weight_openings
#[test]
fn test_sp3_weight_opening_verification_passes() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, weight_claims) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );

    // Deserialize MleOpeningProof from hardcoded artifact data (v19)
    let mle_data = build_sp3_weight_opening_proof_data();
    let mut mle_span = mle_data.span();
    let proof: MleOpeningProof = Serde::deserialize(ref mle_span).unwrap();

    // Weight commitment (same in v18/v19 — commitment is weight-only)
    let weight_commitment: felt252 =
        0x0280b62c993d021a4be8ac506a2be7e41b8f4964c23a68f58d950761e3d73ded;

    let wc_span = weight_claims.span();
    let claim = wc_span.at(0);

    // Verify the MLE opening proof
    let valid = verify_mle_opening(
        weight_commitment,
        @proof,
        claim.eval_point.span(),
        ref ch,
    );
    assert!(valid, "SP3_WEIGHT_MLE_OPENING_FAILED");

    // After weight opening verification, channel digest should match Rust (v19)
    let expected_final_digest: felt252 =
        0x03abfb5efb48a85e864e492d69a551d9c16594c916b661fd247da8e30bc5d2d8;
    assert!(ch.digest == expected_final_digest, "SP3_FINAL_DIGEST_AFTER_WEIGHT_OPENING");
}

// ============================================================================
// Test 9: SP3 Tampered Weight Opening -- Rejected
// ============================================================================

/// Tamper the weight commitment (change last hex digit) and verify that
/// the MLE opening proof is rejected.
#[test]
fn test_sp3_tampered_weight_opening_rejected() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, weight_claims) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );

    let mle_data = build_sp3_weight_opening_proof_data();
    let mut mle_span = mle_data.span();
    let proof: MleOpeningProof = Serde::deserialize(ref mle_span).unwrap();

    // TAMPERED weight commitment: last hex digit changed (d -> e)
    let bad_commitment: felt252 =
        0x0280b62c993d021a4be8ac506a2be7e41b8f4964c23a68f58d950761e3d73dee;

    let wc_span = weight_claims.span();
    let claim = wc_span.at(0);

    let valid = verify_mle_opening(
        bad_commitment,
        @proof,
        claim.eval_point.span(),
        ref ch,
    );
    assert!(!valid, "SP3_TAMPERED_COMMITMENT_SHOULD_REJECT");
}
