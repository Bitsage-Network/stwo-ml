/// SP3 Cross-Language E2E Tests
///
/// Consumes proof artifacts generated by the Rust prover (stwo-ml) and verifies
/// them in Cairo. This is the MOST IMPORTANT test category — it proves that
/// the Cairo verifier produces identical Fiat-Shamir transcripts as the Rust
/// prover, which is the foundation of soundness.
///
/// Artifact: stwo-ml/tests/artifacts/sp3_matmul_only_proof.json
///   Model: 1x4 input → MatMul(4x2) → 1x2 output
///   Input: [1, 2, 3, 4], Output: [50, 60]
///   Calldata: 51 felts, 1 weight commitment, 2 sumcheck rounds

use elo_cairo_verifier::field::{
    QM31, CM31, qm31_new, qm31_eq, fold_mle_eval,
};
use elo_cairo_verifier::channel::{
    PoseidonChannel, channel_default, channel_mix_u64,
    channel_mix_secure_field, channel_draw_qm31,
};
use elo_cairo_verifier::types::{GKRClaim, MleOpeningProof};
use elo_cairo_verifier::model_verifier::verify_gkr_model;
use elo_cairo_verifier::mle::verify_mle_opening;

// ============================================================================
// Helpers
// ============================================================================

/// Real-only QM31 from a u64.
fn mk(a: u64) -> QM31 {
    QM31 { a: CM31 { a, b: 0 }, b: CM31 { a: 0, b: 0 } }
}

/// Seed the channel identically to the Rust GKR prover/verifier.
///
/// Rust seeding (gkr/verifier.rs:56-59):
///   channel.mix_u64(d);              // number of layers
///   channel.mix_u64(input_rows);     // input shape row
///   channel.mix_u64(input_cols);     // input shape col
fn seed_channel_rust(ref ch: PoseidonChannel, d: u64, input_rows: u64, input_cols: u64) {
    channel_mix_u64(ref ch, d);
    channel_mix_u64(ref ch, input_rows);
    channel_mix_u64(ref ch, input_cols);
}

/// Construct the initial output claim by:
///   1. Drawing log_out_vars random QM31 challenges
///   2. Evaluating the output MLE at those challenges
///   3. Mixing the output value into the channel
///
/// For output [50, 60] (1x2 matrix, log_vars=1):
///   r_out = [draw_qm31()]
///   output_value = fold_mle_eval(r0, mk(50), mk(60))
///   mix_secure_field(output_value)
fn construct_output_claim(
    ref ch: PoseidonChannel, output_v0: u64, output_v1: u64,
) -> GKRClaim {
    // Draw 1 QM31 challenge (log_out_rows=0, log_out_cols=1, total=1)
    let r0 = channel_draw_qm31(ref ch);

    // Evaluate output MLE: f(r0) = v0*(1-r0) + v1*r0
    let output_value = fold_mle_eval(r0, mk(output_v0), mk(output_v1));

    // Mix output value into channel
    channel_mix_secure_field(ref ch, output_value);

    GKRClaim {
        point: array![r0],
        value: output_value,
    }
}

/// Build the proof_data from the SP3 matmul-only artifact.
///
/// This is calldata[1..35) from sp3_matmul_only_proof.json:
///   [0] tag=0 (MatMul)
///   [1] num_rounds=2
///   [2..13]  round[0]: c0(4), c1(4), c2(4)
///   [14..25] round[1]: c0(4), c1(4), c2(4)
///   [26..29] final_a_eval (QM31)
///   [30..33] final_b_eval (QM31)
fn build_sp3_matmul_only_proof_data() -> Array<felt252> {
    array![
        // tag = MatMul (0)
        0x0,
        // num_rounds = 2
        0x2,
        // round[0].c0 (QM31)
        0x4c3999da, 0x34cddf9a, 0x447004b2, 0x4b11507f,
        // round[0].c1 (QM31)
        0x104ccd2e, 0x1bbd2a23, 0x5eab0ee, 0xec1c0aa,
        // round[0].c2 (QM31)
        0x10, 0x0, 0x0, 0x0,
        // round[1].c0 (QM31)
        0x79239fc, 0x5bf28cca, 0x1aa07903, 0x515b9e3d,
        // round[1].c1 (QM31)
        0x41374020, 0x3cc351b7, 0x5a5e480c, 0x3a5275e6,
        // round[1].c2 (QM31)
        0x2, 0x0, 0x0, 0x0,
        // final_a_eval (QM31)
        0x544a5325, 0x6ae551de, 0x5205e05c, 0x6455cdd,
        // final_b_eval (QM31)
        0x6ca7d990, 0x3cb9ee46, 0x65866cf4, 0x503b29e4,
        // num_deferred = 0 (no DAG Add layers)
        0x0,
    ]
}

// ============================================================================
// Test 1: SP3 Matmul-Only — Channel Digest Matches Rust
// ============================================================================

/// Full cross-language verification:
///   1. Seed channel identically to Rust prover
///   2. Construct initial output claim from output=[50,60]
///   3. Run verify_gkr_model with proof_data from artifact
///   4. Assert final channel digest == Rust's final_channel_digest
///
/// This test catches ANY Fiat-Shamir transcript divergence between
/// Cairo and Rust — the most critical soundness property.
#[test]
fn test_sp3_matmul_only_channel_digest() {
    let mut ch = channel_default();

    // 1. Seed channel (Rust protocol: d, input_rows, input_cols)
    seed_channel_rust(ref ch, 1, 1, 4);

    // 2. Construct initial output claim
    //    Output: [50, 60] → 1×2 matrix → MLE over 1 variable
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    // 3. Run GKR model verification
    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2]; // m=1, k=4, n=2

    let (_final_claim, _) = verify_gkr_model(
        proof_data.span(),
        1,                          // num_layers
        matmul_dims.span(),
        array![].span(),            // no dequantize layers
        initial_claim,
        ref ch,
    );

    // 4. Assert channel digest matches Rust artifact
    //    From sp3_matmul_only_proof.json → verification.final_channel_digest
    let expected_digest: felt252 =
        0x00c314dd4a66faa626a7847832d30b6316c4d2005e6e8aa00c824ffa6db3239f;

    assert!(ch.digest == expected_digest, "SP3_DIGEST_MISMATCH");
}

// ============================================================================
// Test 2: SP3 Matmul-Only — Final Claim Value Matches Rust
// ============================================================================

/// Verify that the final claim (input claim) from verify_gkr_model
/// matches the expected input_claim.value from the Rust artifact.
///
/// For a single MatMul layer, the final claim value should equal
/// final_a_eval from the sumcheck proof.
#[test]
fn test_sp3_matmul_only_final_claim_value() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (final_claim, _) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );

    // From artifact: input_claim.value = final_a_eval
    // = QM31(0x544a5325, 0x6ae551de, 0x5205e05c, 0x6455cdd)
    let expected_value = qm31_new(0x544a5325, 0x6ae551de, 0x5205e05c, 0x6455cdd);
    assert!(qm31_eq(final_claim.value, expected_value), "SP3_CLAIM_VALUE_MISMATCH");

    // Final claim point should have 2 elements (log_m=0 + log_k=2 sumcheck challenges)
    assert!(final_claim.point.len() == 2, "SP3_CLAIM_POINT_LEN");
}

// ============================================================================
// Test 3: SP3 Matmul-Only — Final Claim Point Matches Rust
// ============================================================================

/// Verify the final claim point coordinates match the artifact's input_claim.point.
/// Point = [s0, s1] — the 2 sumcheck challenges from the MatMul reduction.
#[test]
fn test_sp3_matmul_only_final_claim_point() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (final_claim, _) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );

    // From artifact: input_claim.point[0]
    let expected_p0 = qm31_new(0x6fa4819a, 0x6aba80e5, 0x131c737a, 0x3ed440b7);
    // From artifact: input_claim.point[1]
    let expected_p1 = qm31_new(0x75014fee, 0x15705013, 0x2bccf968, 0x89cdb6e);

    let point_span = final_claim.point.span();
    assert!(qm31_eq(*point_span.at(0), expected_p0), "SP3_POINT_0_MISMATCH");
    assert!(qm31_eq(*point_span.at(1), expected_p1), "SP3_POINT_1_MISMATCH");
}

// ============================================================================
// Test 4: SP3 Tampered Round Poly — Rejected
// ============================================================================

/// Tamper the first round polynomial coefficient (c0) in the MatMul proof.
/// The verifier should detect this via MATMUL_ROUND_SUM_MISMATCH.
///
/// This test verifies that any modification to the proof data causes
/// a Fiat-Shamir transcript failure — proving completeness of binding.
#[test]
#[should_panic(expected: "MATMUL_ROUND_SUM_MISMATCH")]
fn test_sp3_matmul_only_tampered_rejects() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    // Build proof data with tampered round[0].c0 (first QM31 component +1)
    let proof_data: Array<felt252> = array![
        0x0,          // tag
        0x2,          // num_rounds
        // round[0].c0 — TAMPERED: 0x4c3999da → 0x4c3999db (+1)
        0x4c3999db, 0x34cddf9a, 0x447004b2, 0x4b11507f,
        0x104ccd2e, 0x1bbd2a23, 0x5eab0ee, 0xec1c0aa,
        0x10, 0x0, 0x0, 0x0,
        0x79239fc, 0x5bf28cca, 0x1aa07903, 0x515b9e3d,
        0x41374020, 0x3cc351b7, 0x5a5e480c, 0x3a5275e6,
        0x2, 0x0, 0x0, 0x0,
        0x544a5325, 0x6ae551de, 0x5205e05c, 0x6455cdd,
        0x6ca7d990, 0x3cb9ee46, 0x65866cf4, 0x503b29e4,
    ];

    let matmul_dims: Array<u32> = array![1, 4, 2];

    // This should panic with MATMUL_ROUND_SUM_MISMATCH
    let (_final_claim, _) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );
}

// ============================================================================
// Test 5: SP3 Tampered Final Eval — Rejected
// ============================================================================

/// Tamper the final_a_eval. The verifier should detect this via
/// MATMUL_FINAL_MISMATCH (final_a * final_b != last round sum).
#[test]
#[should_panic(expected: "MATMUL_FINAL_MISMATCH")]
fn test_sp3_matmul_only_tampered_final_rejects() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    // Build proof data with tampered final_a_eval (first component +1)
    let proof_data: Array<felt252> = array![
        0x0,
        0x2,
        0x4c3999da, 0x34cddf9a, 0x447004b2, 0x4b11507f,
        0x104ccd2e, 0x1bbd2a23, 0x5eab0ee, 0xec1c0aa,
        0x10, 0x0, 0x0, 0x0,
        0x79239fc, 0x5bf28cca, 0x1aa07903, 0x515b9e3d,
        0x41374020, 0x3cc351b7, 0x5a5e480c, 0x3a5275e6,
        0x2, 0x0, 0x0, 0x0,
        // final_a_eval — TAMPERED: 0x544a5325 → 0x544a5326 (+1)
        0x544a5326, 0x6ae551de, 0x5205e05c, 0x6455cdd,
        0x6ca7d990, 0x3cb9ee46, 0x65866cf4, 0x503b29e4,
    ];

    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, _) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );
}

// ============================================================================
// Test 6: SP3 Wrong Output — Initial Claim Mismatch
// ============================================================================

/// Provide wrong output values (51, 60 instead of 50, 60).
/// The initial claim value will differ → round sum mismatch in the first
/// sumcheck round (claim.value = p(0) + p(1) won't hold).
#[test]
#[should_panic(expected: "MATMUL_ROUND_SUM_MISMATCH")]
fn test_sp3_matmul_only_wrong_output_rejects() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);

    // Wrong output: [51, 60] instead of [50, 60]
    let initial_claim = construct_output_claim(ref ch, 51, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, _) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );
}

// ============================================================================
// Weight MLE Opening Proof Data (from sp3_matmul_only_proof.json)
// ============================================================================

/// Build the MleOpeningProof calldata from the SP3 artifact.
///
/// This is weight_opening_calldata_hex[1..] from the artifact (skip count).
/// 184 felts encoding a single MleOpeningProof for the 4x2 weight matrix.
///
/// MLE has 8 elements (4*2), log2(8)=3 folding rounds, 4 spot-check queries.
/// Merkle tree: 2 intermediate roots, 4 queries x 3 rounds each.
fn build_sp3_weight_opening_proof_data() -> Array<felt252> {
    array![
        // intermediate_roots: Array<felt252> (len=2)
        0x2,
        0x32af8fd28517d67b4a36b4a05b422da2d55a15a9c1d6ffd2c99bed93b1e3659,
        0x7bfad8eeed46175876d7a4bd1bd5bec361195754ca1ea10af1ca1b157bf3153,
        // queries: Array<MleQueryProof> (len=4)
        0x4,
        // ---- Query 0: initial_pair_index=0, rounds=3 ----
        0x0, 0x3,
        // Q0 R0: left(1,0,0,0), right(2,0,0,0), left_sibs(3), right_sibs(3)
        0x1, 0x0, 0x0, 0x0,
        0x2, 0x0, 0x0, 0x0,
        0x3,
        0x10000000600000000000000000000000,
        0x237489190b283d778a874e504a4e6f70b5971003c8fbd81654e589ffb30450,
        0x523409a865968ce30bd0ff99140c9dc235ec925370279c43d59beb5bfe4c1ac,
        0x3,
        0x10000000800000000000000000000000,
        0x495ab9242f2ec905679ed8d6af6414b4dc897336d31719b68e573911043c180,
        0x12a72ae943d9780522015b25a33677c130cf2e3ca7cab6111f387c0572cea41,
        // Q0 R1: left, right, left_sibs(2), right_sibs(2)
        0x44133347, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x4413334b, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x2,
        0x1882666939bbd2a220bd561dc3b0702a,
        0x4458b2d010efa202ef05ef9980c80ca06d4d8bd4718b512a20cecc76818631,
        0x2,
        0x18826669b9bbd2a220bd561dc3b0702a,
        0xf7e1013873b4fe7e32273e9ea1aa97c075a6111259f180555224f386c5510f,
        // Q0 R2: left, right, left_sibs(1), right_sibs(1)
        0x2a539b3, 0x11d94e20, 0xdec7a24, 0x3f017308,
        0x2a539b5, 0x11d94e20, 0xdec7a24, 0x3f017308,
        0x1,
        0x1054a736a476538806f63d123f017308,
        0x1,
        0x1054a7366476538806f63d123f017308,
        // ---- Query 1: initial_pair_index=2, rounds=3 ----
        0x2, 0x3,
        // Q1 R0
        0x5, 0x0, 0x0, 0x0,
        0x6, 0x0, 0x0, 0x0,
        0x3,
        0x10000000e00000000000000000000000,
        0x1b537b28eb8c5c619cecea97d60b41e915ab177027b4ef363162ca5742e2184,
        0x523409a865968ce30bd0ff99140c9dc235ec925370279c43d59beb5bfe4c1ac,
        0x3,
        0x10000001000000000000000000000000,
        0x7629454ecc4eaca72b489df1ec392edf4bb1df3dca0b8c3bbf5ab1d1a1cbd9f,
        0x12a72ae943d9780522015b25a33677c130cf2e3ca7cab6111f387c0572cea41,
        // Q1 R1
        0x44133347, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x4413334b, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x2,
        0x1882666939bbd2a220bd561dc3b0702a,
        0x4458b2d010efa202ef05ef9980c80ca06d4d8bd4718b512a20cecc76818631,
        0x2,
        0x18826669b9bbd2a220bd561dc3b0702a,
        0xf7e1013873b4fe7e32273e9ea1aa97c075a6111259f180555224f386c5510f,
        // Q1 R2
        0x2a539b3, 0x11d94e20, 0xdec7a24, 0x3f017308,
        0x2a539b5, 0x11d94e20, 0xdec7a24, 0x3f017308,
        0x1,
        0x1054a736a476538806f63d123f017308,
        0x1,
        0x1054a7366476538806f63d123f017308,
        // ---- Query 2: initial_pair_index=3, rounds=3 ----
        0x3, 0x3,
        // Q2 R0
        0x7, 0x0, 0x0, 0x0,
        0x8, 0x0, 0x0, 0x0,
        0x3,
        0x10000000a00000000000000000000000,
        0x1b537b28eb8c5c619cecea97d60b41e915ab177027b4ef363162ca5742e2184,
        0x523409a865968ce30bd0ff99140c9dc235ec925370279c43d59beb5bfe4c1ac,
        0x3,
        0x10000000c00000000000000000000000,
        0x7629454ecc4eaca72b489df1ec392edf4bb1df3dca0b8c3bbf5ab1d1a1cbd9f,
        0x12a72ae943d9780522015b25a33677c130cf2e3ca7cab6111f387c0572cea41,
        // Q2 R1
        0x44133349, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x4413334d, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x2,
        0x18826668f9bbd2a220bd561dc3b0702a,
        0x4458b2d010efa202ef05ef9980c80ca06d4d8bd4718b512a20cecc76818631,
        0x2,
        0x1882666979bbd2a220bd561dc3b0702a,
        0xf7e1013873b4fe7e32273e9ea1aa97c075a6111259f180555224f386c5510f,
        // Q2 R2
        0x2a539b3, 0x11d94e20, 0xdec7a24, 0x3f017308,
        0x2a539b5, 0x11d94e20, 0xdec7a24, 0x3f017308,
        0x1,
        0x1054a736a476538806f63d123f017308,
        0x1,
        0x1054a7366476538806f63d123f017308,
        // ---- Query 3: initial_pair_index=0, rounds=3 ----
        0x0, 0x3,
        // Q3 R0
        0x1, 0x0, 0x0, 0x0,
        0x2, 0x0, 0x0, 0x0,
        0x3,
        0x10000000600000000000000000000000,
        0x237489190b283d778a874e504a4e6f70b5971003c8fbd81654e589ffb30450,
        0x523409a865968ce30bd0ff99140c9dc235ec925370279c43d59beb5bfe4c1ac,
        0x3,
        0x10000000800000000000000000000000,
        0x495ab9242f2ec905679ed8d6af6414b4dc897336d31719b68e573911043c180,
        0x12a72ae943d9780522015b25a33677c130cf2e3ca7cab6111f387c0572cea41,
        // Q3 R1
        0x44133347, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x4413334b, 0x66ef4a88, 0x417aac3b, 0x43b0702a,
        0x2,
        0x1882666939bbd2a220bd561dc3b0702a,
        0x4458b2d010efa202ef05ef9980c80ca06d4d8bd4718b512a20cecc76818631,
        0x2,
        0x18826669b9bbd2a220bd561dc3b0702a,
        0xf7e1013873b4fe7e32273e9ea1aa97c075a6111259f180555224f386c5510f,
        // Q3 R2
        0x2a539b3, 0x11d94e20, 0xdec7a24, 0x3f017308,
        0x2a539b5, 0x11d94e20, 0xdec7a24, 0x3f017308,
        0x1,
        0x1054a736a476538806f63d123f017308,
        0x1,
        0x1054a7366476538806f63d123f017308,
        // final_value: QM31(0x6ca7d990, 0x3cb9ee46, 0x65866cf4, 0x503b29e4)
        0x6ca7d990, 0x3cb9ee46, 0x65866cf4, 0x503b29e4,
    ]
}

// ============================================================================
// Test 7: SP3 Matmul-Only -- Weight Claims Match Artifact
// ============================================================================

/// Verify that the weight claims collected during the GKR walk match the
/// hardcoded values from the Rust artifact.
///
/// Weight claim for a MatMul layer:
///   eval_point = [r_j || sumcheck_challenges]  (column + sumcheck challenges)
///   expected_value = final_b_eval              (weight MLE evaluation)
#[test]
fn test_sp3_weight_claims_match_artifact() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, weight_claims) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );

    // Should have exactly 1 weight claim (1 matmul layer)
    assert!(weight_claims.len() == 1, "SP3_WEIGHT_CLAIM_COUNT");

    let wc_span = weight_claims.span();
    let claim = wc_span.at(0);

    // eval_point should have 3 QM31s: [r_j(1), s0(1), s1(1)]
    // For m=1 (log_m=0), n=2 (log_n=1), k=4 (log_k=2):
    //   r_j = 1 element (col challenge), sumcheck_challenges = 2 elements
    assert!(claim.eval_point.len() == 3, "SP3_EVAL_POINT_LEN");

    // From artifact: weight_claims[0].eval_point
    let ep0 = qm31_new(0x44133346, 0x66ef4a88, 0x417aac3b, 0x43b0702a);
    let ep1 = qm31_new(0x6fa4819a, 0x6aba80e5, 0x131c737a, 0x3ed440b7);
    let ep2 = qm31_new(0x75014fee, 0x15705013, 0x2bccf968, 0x89cdb6e);

    assert!(qm31_eq(*claim.eval_point.at(0), ep0), "SP3_EVAL_POINT_0");
    assert!(qm31_eq(*claim.eval_point.at(1), ep1), "SP3_EVAL_POINT_1");
    assert!(qm31_eq(*claim.eval_point.at(2), ep2), "SP3_EVAL_POINT_2");

    // From artifact: weight_claims[0].expected_value = final_b_eval
    let expected_val = qm31_new(0x6ca7d990, 0x3cb9ee46, 0x65866cf4, 0x503b29e4);
    assert!(qm31_eq(*claim.expected_value, expected_val), "SP3_WEIGHT_VALUE");
}

// ============================================================================
// Test 8: SP3 Matmul-Only -- Weight MLE Opening Verification Passes
// ============================================================================

/// Full cross-language weight opening verification:
///   1. Run GKR model walk to get weight claims + channel state
///   2. Deserialize MleOpeningProof from artifact data via Serde
///   3. Call verify_mle_opening with the weight commitment from artifact
///   4. Assert verification passes
///   5. Assert final channel digest matches Rust's digest_after_weight_openings
///
/// This test proves that:
///   - The GKR walk produces the correct weight evaluation point
///   - The Poseidon Merkle tree commitment protocol matches Rust byte-for-byte
///   - The MLE folding algebra is identical between Cairo and Rust
///   - The Fiat-Shamir transcript (channel) stays synchronized through weight openings
#[test]
fn test_sp3_weight_opening_verification_passes() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, weight_claims) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );

    // Deserialize MleOpeningProof from hardcoded artifact data
    let mle_data = build_sp3_weight_opening_proof_data();
    let mut mle_span = mle_data.span();
    let proof: MleOpeningProof = Serde::deserialize(ref mle_span).unwrap();

    // Weight commitment from artifact
    let weight_commitment: felt252 =
        0x0280b62c993d021a4be8ac506a2be7e41b8f4964c23a68f58d950761e3d73ded;

    // Get eval_point from weight claim
    let wc_span = weight_claims.span();
    let claim = wc_span.at(0);

    // Verify the MLE opening proof
    let valid = verify_mle_opening(
        weight_commitment,
        @proof,
        claim.eval_point.span(),
        ref ch,
    );
    assert!(valid, "SP3_WEIGHT_MLE_OPENING_FAILED");

    // After weight opening verification, channel digest should match
    // Rust's final_channel_digest from the artifact
    let expected_final_digest: felt252 =
        0x0702d9ae6932f6cbbb05083f0f83d63d70b95999cc9c29c5b8a6e13549ff7f38;
    assert!(ch.digest == expected_final_digest, "SP3_FINAL_DIGEST_AFTER_WEIGHT_OPENING");
}

// ============================================================================
// Test 9: SP3 Tampered Weight Opening -- Rejected
// ============================================================================

/// Tamper the weight commitment (change last hex digit) and verify that
/// the MLE opening proof is rejected. This proves that the weight
/// binding is cryptographically enforced -- a cheating prover cannot
/// substitute different weights without detection.
#[test]
fn test_sp3_tampered_weight_opening_rejected() {
    let mut ch = channel_default();
    seed_channel_rust(ref ch, 1, 1, 4);
    let initial_claim = construct_output_claim(ref ch, 50, 60);

    let proof_data = build_sp3_matmul_only_proof_data();
    let matmul_dims: Array<u32> = array![1, 4, 2];

    let (_final_claim, weight_claims) = verify_gkr_model(
        proof_data.span(), 1, matmul_dims.span(),
        array![].span(), initial_claim, ref ch,
    );

    // Deserialize MleOpeningProof (same valid proof data)
    let mle_data = build_sp3_weight_opening_proof_data();
    let mut mle_span = mle_data.span();
    let proof: MleOpeningProof = Serde::deserialize(ref mle_span).unwrap();

    // TAMPERED weight commitment: last hex digit changed (d -> e)
    let bad_commitment: felt252 =
        0x0280b62c993d021a4be8ac506a2be7e41b8f4964c23a68f58d950761e3d73dee;

    let wc_span = weight_claims.span();
    let claim = wc_span.at(0);

    // Verification should FAIL -- Merkle root mismatch
    let valid = verify_mle_opening(
        bad_commitment,
        @proof,
        claim.eval_point.span(),
        ref ch,
    );
    assert!(!valid, "SP3_TAMPERED_COMMITMENT_SHOULD_REJECT");
}
